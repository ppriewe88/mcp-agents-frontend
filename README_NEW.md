Hier deine Zusammenfassung aus einer gemeinsamen Session (Du, ich, "gef√ºhrtes Programmieren", mein entstandenes Repo): üîπ Projektstatus ‚Äì Zusammenfassung (f√ºr Fortsetzung) 1) Repository / Struktur (Next.js + TypeScript) Root: src/ app/ ‚Äì Next.js App Router layout.tsx Root-Layout Enth√§lt globale Struktur (Sidebar etc.) globals.css page.tsx Startseite (Placeholder / Welcome) agents/ page.tsx Agents-Seite Enth√§lt: Plus-Button √ñffnet AgentCreateModal L√§dt bestehende Agents aus Cosmos DB (loadAgents) Rendert Agenten als Kacheln (Card) page.module.css api/ storage/[container]/route.ts Generische Storage-Route POST ‚Üí Speichern in Cosmos DB GET ‚Üí Laden aus Cosmos DB Container wird √ºber URL bestimmt (/api/storage/agents, ‚Ä¶) 2) UI-Komponenten (src/ui/) Wiederverwendbare, dumme UI-Bausteine: Sidebar.tsx NavButton.tsx AddButton.tsx Button.tsx Card.tsx (Kachel) Modal.tsx TextInput.tsx TextArea.tsx CheckBox.tsx ‚Üí Keine Fachlogik, nur Darstellung + Callbacks. 3) Models (src/models/) agent.ts Agent-Datenmodell inkl. Logik: type Agent = { name: string; description: string; systemPrompt: string; directAnswerValidationPrompt: string; directAnswersAllowed: boolean; }; Zus√§tzlich: normalizeAgent(agent) validateAgent(agent) Alle Pflichtfelder werden gepr√ºft directAnswerValidationPrompt ist immer Pflicht (Backend-Vorgabe) 4) Storage-Layer (Frontend) src/routing/storage.ts Generische, getypte Storage-Funktionen (Frontend-Seite): saveItem<T>(container: string, item: T) loadItems<T>(container: string) Typ: StoredItem<T> = T & { id: string; partitionKey: string } Kommuniziert ausschlie√ülich mit: /api/storage/[container] 5) Server-seitiger Cosmos-Zugriff src/server/cosmos.ts Initialisiert CosmosClient Liest ENV: COSMOS_ENDPOINT COSMOS_KEY COSMOS_DATABASE_ID Partition Key: Path: /partitionKey Wert: serverseitig fix "default" 6) Feature: Agents src/features/agents/agents.storage.ts Fachlicher Wrapper um generisches Storage: saveAgent(agent) loadAgents() ‚Üí Kapselt Container-Namen ("agents"). src/features/agents/AgentCreateModal.tsx Client Component Formular f√ºr Agent-Erstellung Felder: Name Description System Prompt DirectAnswersAllowed (Checkbox) DirectAnswerValidationPrompt (immer Pflicht) Baut Agent normalizeAgent + validateAgent √úbergibt an onSave(agent) 7) Agents Page (app/agents/page.tsx) "use client" State: agents isLoading error useEffect: loadAgents() bei Mount Plus-Button: √∂ffnet AgentCreateModal Save: saveAgent(agent) danach loadAgents() neu Anzeige: Grid Jede Agenten-Kachel = Card 8) Architekturentscheidung (wichtig!) Cosmos DB wird ausschlie√ülich vom Next.js Data Layer bedient √ºber API Routes (app/api/storage) Python Backend (FastAPI): Nur f√ºr: LLM-Calls Agent Execution Separate Kundendaten-DB Kein Zugriff auf Cosmos DB 9) N√§chster geplanter Schritt (im neuen Chat) Feature: MCP-Server Ziel: Eigene Seite (analog zu Agents) Plus-Button Modal zum Anlegen eines MCP-Servers Datenmodell: MCPServer = { name: string; url: string; } Speicherung in Cosmos DB Container: servers Wiederverwendung: Storage-Layer Card Modal-Struktur Wrapper servers.storage.ts --------------------- Wir machen jetzt weiter mit MCP-Servern (einpflege, speicherung/loading aus cosmos-DB)
